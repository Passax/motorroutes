<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motorroutes — NL · BE · DE</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            line-height: 1.6;
        }

        /* ===== WELCOME SCREEN ===== */
        #welcome {
            position: fixed;
            inset: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 35%, #0f3460 65%, #162447 100%);
            transition: opacity 0.6s ease, transform 0.6s ease;
            overflow: hidden;
        }

        #welcome::before {
            content: '';
            position: absolute;
            width: 700px;
            height: 700px;
            border-radius: 50%;
            border: 2px solid rgba(233, 69, 96, 0.08);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #welcome::after {
            content: '';
            position: absolute;
            width: 450px;
            height: 450px;
            border-radius: 50%;
            border: 1px solid rgba(233, 69, 96, 0.05);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #welcome.hide {
            opacity: 0;
            transform: scale(1.05);
            pointer-events: none;
        }

        .welcome-box {
            position: relative;
            z-index: 1;
            text-align: center;
            max-width: 520px;
            padding: 2rem;
            width: 100%;
        }

        .welcome-icon {
            font-size: 4.5rem;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 30px rgba(233, 69, 96, 0.4));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .welcome-box h1 {
            font-size: 2.5rem;
            font-weight: 800;
            color: #fff;
            letter-spacing: -0.5px;
        }

        .welcome-box h1 span { color: #e94560; }

        .welcome-subtitle {
            color: rgba(255,255,255,0.5);
            font-size: 1rem;
            margin-top: 0.25rem;
        }

        .welcome-prompt {
            color: rgba(255,255,255,0.7);
            font-size: 0.95rem;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .country-picker {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .country-btn {
            padding: 0.5rem 1.25rem;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.12);
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .country-btn:hover { border-color: rgba(233,69,96,0.5); color: #fff; }
        .country-btn.active { background: rgba(233,69,96,0.2); border-color: #e94560; color: #fff; }

        .postcode-input {
            width: 100%;
            max-width: 280px;
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.06);
            color: #fff;
            font-size: 1.05rem;
            text-align: center;
            font-family: inherit;
            letter-spacing: 1px;
            outline: none;
            transition: border-color 0.2s;
        }

        .postcode-input::placeholder { color: rgba(255,255,255,0.3); letter-spacing: 0.5px; }
        .postcode-input:focus { border-color: #e94560; }

        .duration-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.95rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .duration-picker {
            display: flex;
            justify-content: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .dur-btn {
            padding: 0.5rem 1rem;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.12);
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dur-btn:hover { border-color: rgba(233,69,96,0.5); color: #e94560; }
        .dur-btn.active { background: #e94560; border-color: #e94560; color: #fff; }

        .welcome-go {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 2rem;
            padding: 0.85rem 2.5rem;
            border-radius: 50px;
            border: none;
            background: linear-gradient(135deg, #e94560, #c23152);
            color: #fff;
            font-size: 1.05rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: inherit;
        }

        .welcome-go:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(233, 69, 96, 0.4);
        }

        .welcome-skip {
            display: block;
            margin-top: 1rem;
            color: rgba(255,255,255,0.35);
            font-size: 0.82rem;
            cursor: pointer;
            background: none;
            border: none;
            font-family: inherit;
            transition: color 0.2s;
        }

        .welcome-skip:hover { color: rgba(255,255,255,0.6); }

        .welcome-status {
            margin-top: 0.75rem;
            font-size: 0.82rem;
            color: rgba(255,255,255,0.5);
            min-height: 1.2em;
        }

        /* ===== HERO ===== */
        .hero {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 40%, #0f3460 70%, #e94560 100%);
            padding: 3rem 2rem 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(90deg, transparent, transparent 50px, rgba(255,255,255,0.015) 50px, rgba(255,255,255,0.015) 51px);
        }

        .hero h1 {
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 800;
            color: #fff;
            position: relative;
        }

        .hero h1 span { color: #e94560; }

        .hero p {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: rgba(255,255,255,0.6);
            margin-top: 0.5rem;
            position: relative;
        }

        .hero .badge {
            display: inline-block;
            margin-top: 1rem;
            padding: 0.4rem 1rem;
            background: rgba(233, 69, 96, 0.15);
            border: 1px solid rgba(233, 69, 96, 0.4);
            border-radius: 50px;
            color: #e94560;
            font-size: 0.8rem;
            font-weight: 600;
            position: relative;
        }

        /* ===== FILTERS ===== */
        .filter-section {
            max-width: 1200px;
            margin: 1.5rem auto 0;
            padding: 0 1.5rem;
        }

        .filter-row {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
            align-items: center;
        }

        .filter-row-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 0.3rem;
            font-weight: 600;
        }

        .filter-btn {
            padding: 0.4rem 0.9rem;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
            background: transparent;
            color: rgba(255,255,255,0.5);
            font-size: 0.78rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover { border-color: rgba(233,69,96,0.4); color: #e94560; }
        .filter-btn.active { background: #e94560; border-color: #e94560; color: #fff; }

        /* ===== MAP ===== */
        .map-section {
            max-width: 1200px;
            margin: 1.5rem auto 0;
            padding: 0 1.5rem;
            position: relative;
        }

        #map {
            width: 100%;
            height: 420px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 1;
        }

        .map-empty {
            position: absolute;
            top: 0;
            left: 1.5rem;
            right: 1.5rem;
            height: 420px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 2;
            transition: opacity 0.3s;
        }

        .map-empty span {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(6px);
            padding: 0.6rem 1.5rem;
            border-radius: 50px;
            font-size: 0.82rem;
            color: rgba(255,255,255,0.5);
        }

        .map-empty.hidden { opacity: 0; }

        .map-loading {
            position: absolute;
            top: 0;
            left: 1.5rem;
            right: 1.5rem;
            height: 420px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            z-index: 4;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .map-loading.visible { opacity: 1; }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .map-loading-text {
            color: rgba(255,255,255,0.7);
            font-size: 0.85rem;
            margin-left: 0.75rem;
        }

        /* ===== POI BAR ===== */
        .poi-bar {
            max-width: 1200px;
            margin: 0.75rem auto 0;
            padding: 0 1.5rem;
            display: none;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .poi-bar.visible { display: flex; }

        .poi-bar-label {
            font-size: 0.72rem;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-right: 0.2rem;
        }

        .poi-btn {
            padding: 0.45rem 0.9rem;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.04);
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        .poi-btn:hover { border-color: rgba(233,69,96,0.5); color: #fff; }
        .poi-btn.active { background: rgba(233,69,96,0.2); border-color: #e94560; color: #fff; }
        .poi-btn.loading { opacity: 0.5; pointer-events: none; }

        .poi-count {
            font-size: 0.68rem;
            background: rgba(233,69,96,0.4);
            color: #fff;
            padding: 0.05rem 0.4rem;
            border-radius: 50px;
            min-width: 18px;
            text-align: center;
        }

        .poi-clear {
            padding: 0.35rem 0.7rem;
            border-radius: 50px;
            border: 1px solid rgba(255,71,87,0.3);
            background: transparent;
            color: rgba(255,71,87,0.6);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            margin-left: auto;
        }

        .poi-clear:hover { border-color: #ff4757; color: #ff4757; }

        /* ===== MAIN / ROUTES ===== */
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem 1.5rem 2.5rem;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 1rem;
            padding-bottom: 0.6rem;
            border-bottom: 2px solid #e94560;
            display: inline-block;
        }

        .route-count {
            font-weight: 400;
            color: rgba(255,255,255,0.35);
            font-size: 1rem;
        }

        .routes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 1.25rem;
            margin-top: 0.75rem;
        }

        /* ===== ROUTE CARD ===== */
        .route-card {
            background: #1a1a2e;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.06);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        .route-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }

        .route-card.selected {
            background: rgba(26, 26, 46, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transform: translateY(-6px);
        }

        .route-card.selected.glow-easy {
            box-shadow: 0 8px 32px rgba(46, 213, 115, 0.25), 0 0 0 1px rgba(46, 213, 115, 0.15);
            border-color: rgba(46, 213, 115, 0.3);
        }

        .route-card.selected.glow-medium {
            box-shadow: 0 8px 32px rgba(255, 165, 2, 0.25), 0 0 0 1px rgba(255, 165, 2, 0.15);
            border-color: rgba(255, 165, 2, 0.3);
        }

        .route-card.selected.glow-advanced {
            box-shadow: 0 8px 32px rgba(255, 71, 87, 0.25), 0 0 0 1px rgba(255, 71, 87, 0.15);
            border-color: rgba(255, 71, 87, 0.3);
        }

        .route-accent { height: 4px; width: 100%; }
        .accent-easy { background: #2ed573; }
        .accent-medium { background: #ffa502; }
        .accent-advanced { background: #ff4757; }
        .accent-generated { background: linear-gradient(90deg, #e94560, #4285f4); }

        .route-header { padding: 1rem 1.25rem 0.4rem; }

        .route-header h2 {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .route-header h2 .route-icon { font-size: 1.2rem; }

        .route-meta {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            padding: 0.2rem 1.25rem 0;
        }

        .meta-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.73rem;
            color: rgba(255,255,255,0.55);
            background: rgba(255,255,255,0.05);
            padding: 0.2rem 0.55rem;
            border-radius: 6px;
        }

        .route-waypoints {
            padding: 0.6rem 1.25rem 0;
            font-size: 0.73rem;
            color: rgba(255,255,255,0.35);
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.15rem;
        }

        .route-waypoints .wp { color: rgba(255,255,255,0.5); }
        .route-waypoints .arrow { color: #e94560; margin: 0 0.1rem; }

        .stop-added {
            display: inline-flex;
            align-items: center;
            gap: 0.15rem;
            font-size: 0.68rem;
            padding: 0.1rem 0.45rem;
            border-radius: 4px;
            background: rgba(66, 133, 244, 0.12);
            color: rgba(66, 133, 244, 0.85);
            border: 1px solid rgba(66, 133, 244, 0.2);
        }

        .route-body { padding: 0.6rem 1.25rem; flex: 1; }

        .route-body p {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.45);
            line-height: 1.5;
        }

        .route-highlights {
            padding: 0 1.25rem 0.6rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .highlight-tag {
            font-size: 0.68rem;
            padding: 0.15rem 0.45rem;
            border-radius: 4px;
            background: rgba(233, 69, 96, 0.08);
            color: rgba(233, 69, 96, 0.75);
            border: 1px solid rgba(233, 69, 96, 0.12);
        }

        .route-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 1.25rem 0.4rem;
            border-top: 1px solid rgba(255,255,255,0.04);
            margin-top: auto;
        }

        .difficulty {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0.25rem 0.65rem;
            border-radius: 50px;
        }

        .difficulty.easy {
            background: rgba(46, 213, 115, 0.12);
            color: #2ed573;
            border: 1px solid rgba(46, 213, 115, 0.25);
        }

        .difficulty.medium {
            background: rgba(255, 165, 2, 0.12);
            color: #ffa502;
            border: 1px solid rgba(255, 165, 2, 0.25);
        }

        .difficulty.advanced {
            background: rgba(255, 71, 87, 0.12);
            color: #ff4757;
            border: 1px solid rgba(255, 71, 87, 0.25);
        }

        .difficulty.generated {
            background: rgba(66, 133, 244, 0.12);
            color: #4285f4;
            border: 1px solid rgba(66, 133, 244, 0.25);
        }

        .route-type { font-size: 0.72rem; color: rgba(255,255,255,0.3); }

        /* ===== ACTION BUTTONS ===== */
        .route-actions {
            display: none;
            gap: 0.5rem;
            padding: 0.4rem 1.25rem 1rem;
        }

        .route-card.selected .route-actions { display: flex; }

        .action-btn {
            flex: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            padding: 0.5rem 0.6rem;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.7);
            font-size: 0.76rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            font-family: inherit;
        }

        .action-btn.nav-btn:hover {
            background: rgba(66, 133, 244, 0.18);
            border-color: rgba(66, 133, 244, 0.4);
            color: #4285f4;
        }

        .action-btn.gpx-btn:hover {
            background: rgba(46, 213, 115, 0.18);
            border-color: rgba(46, 213, 115, 0.4);
            color: #2ed573;
        }

        /* ===== TIPS ===== */
        .tips {
            margin-top: 2.5rem;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1rem;
        }

        .tip-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 1.1rem;
        }

        .tip-card h3 {
            font-size: 0.85rem;
            color: #fff;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .tip-card p { font-size: 0.78rem; color: rgba(255,255,255,0.4); }

        /* ===== FOOTER ===== */
        footer {
            text-align: center;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border-top: 1px solid rgba(255,255,255,0.06);
            color: rgba(255,255,255,0.25);
            font-size: 0.8rem;
        }

        footer span { color: #e94560; }

        /* ===== LEAFLET POPUP (dark) ===== */
        .leaflet-popup-content-wrapper {
            background: #1a1a2e;
            color: #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .leaflet-popup-tip { background: #1a1a2e; }

        .leaflet-popup-content {
            margin: 10px 14px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 0.82rem;
            line-height: 1.4;
        }

        .leaflet-popup-content a { color: #e94560; text-decoration: none; font-weight: 600; }
        .leaflet-popup-content a:hover { text-decoration: underline; }
        .leaflet-popup-close-button { color: rgba(255,255,255,0.5) !important; }

        .leaflet-popup-content .poi-add-btn {
            display: inline-block;
            margin-top: 0.4rem;
            padding: 0.3rem 0.7rem;
            border-radius: 6px;
            border: 1px solid rgba(233,69,96,0.4);
            background: rgba(233,69,96,0.1);
            color: #e94560;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .leaflet-popup-content .poi-add-btn:hover {
            background: rgba(233,69,96,0.25);
        }

        /* POI div icon */
        .poi-div-icon {
            background: none !important;
            border: none !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poi-emoji {
            font-size: 1.6rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.6));
        }

        .attraction-emoji {
            font-size: 1.1rem;
            opacity: 0.75;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 600px) {
            .routes { grid-template-columns: 1fr; }
            .hero { padding: 2.5rem 1.25rem 1.5rem; }
            main { padding: 1.25rem 1rem; }
            .filter-section { padding: 0 1rem; }
            .tips { grid-template-columns: 1fr; }
            #map { height: 300px; }
            .map-empty, .map-loading { height: 300px; left: 1rem; right: 1rem; }
            .map-section { padding: 0 1rem; }
            .poi-bar { padding: 0 1rem; }
            .route-actions { flex-direction: column; }
            .welcome-box h1 { font-size: 2rem; }
            .welcome-icon { font-size: 3.5rem; }
        }
    </style>
</head>
<body>

<!-- ===== WELCOME SCREEN ===== -->
<div id="welcome">
    <div class="welcome-box">
        <div class="welcome-icon">&#x1F3CD;&#xFE0F;</div>
        <h1>Motor<span>routes</span></h1>
        <p class="welcome-subtitle">Nederland &middot; Belgi&euml; &middot; Duitsland</p>

        <p class="welcome-prompt">Waar vertrek je?</p>
        <div class="country-picker">
            <button class="country-btn active" data-country="nl">&#x1F1F3;&#x1F1F1; Nederland</button>
            <button class="country-btn" data-country="be">&#x1F1E7;&#x1F1EA; Belgi&euml;</button>
            <button class="country-btn" data-country="de">&#x1F1E9;&#x1F1EA; Deutschland</button>
        </div>
        <input type="text" class="postcode-input" id="postcodeInput" placeholder="Jouw postcode" maxlength="7" autocomplete="postal-code">

        <p class="duration-label">Hoelang wil je rijden?</p>
        <div class="duration-picker" id="welcomeDuration">
            <button class="dur-btn active" data-dur="all">Alle</button>
            <button class="dur-btn" data-dur="2">2 uur</button>
            <button class="dur-btn" data-dur="3">3 uur</button>
            <button class="dur-btn" data-dur="4">4 uur</button>
            <button class="dur-btn" data-dur="5">5+ uur</button>
        </div>

        <button class="welcome-go" id="welcomeGo">&#x1F50D; Zoek routes</button>
        <div class="welcome-status" id="welcomeStatus"></div>
        <button class="welcome-skip" id="welcomeSkip">Bekijk alle routes &rarr;</button>
    </div>
</div>

<!-- ===== MAIN APP ===== -->
<div id="app">
    <header class="hero">
        <h1>Motor<span>routes</span></h1>
        <p>De mooiste motorritten door Nederland, Belgi&euml; en Duitsland</p>
        <div class="badge" id="heroBadge">28 routes &bull; 3 landen &bull; alle niveaus</div>
    </header>

    <div class="filter-section">
        <div class="filter-row">
            <span class="filter-row-label">Duur</span>
            <button class="filter-btn active" data-group="dur" data-val="all">Alle</button>
            <button class="filter-btn" data-group="dur" data-val="2">2 uur</button>
            <button class="filter-btn" data-group="dur" data-val="3">3 uur</button>
            <button class="filter-btn" data-group="dur" data-val="4">4 uur</button>
            <button class="filter-btn" data-group="dur" data-val="5">5+ uur</button>
        </div>
        <div class="filter-row">
            <span class="filter-row-label">Type</span>
            <button class="filter-btn active" data-group="type" data-val="all">Alle</button>
            <button class="filter-btn" data-group="type" data-val="easy">Beginner</button>
            <button class="filter-btn" data-group="type" data-val="medium">Gemiddeld</button>
            <button class="filter-btn" data-group="type" data-val="advanced">Gevorderd</button>
            <button class="filter-btn" data-group="type" data-val="kust">Kust &amp; water</button>
            <button class="filter-btn" data-group="type" data-val="polder">Polders</button>
            <button class="filter-btn" data-group="type" data-val="bos">Bossen</button>
            <button class="filter-btn" data-group="type" data-val="bergen">Bergen &amp; bochten</button>
        </div>
    </div>

    <div class="map-section">
        <div id="map"></div>
        <div class="map-empty" id="mapEmpty"><span>Klik op een route om deze op de kaart te zien</span></div>
        <div class="map-loading" id="mapLoading">
            <div class="spinner"></div>
            <span class="map-loading-text" id="mapLoadingText">Route laden...</span>
        </div>
    </div>

    <!-- POI bar -->
    <div class="poi-bar" id="poiBar">
        <span class="poi-bar-label">Zoek langs route</span>
        <button class="poi-btn" data-poi="fuel">&#x26FD; Benzinepomp</button>
        <button class="poi-btn" data-poi="fast_food">&#x1F35F; Cafetaria</button>
        <button class="poi-btn" data-poi="restaurant">&#x1F37D;&#xFE0F; Restaurant</button>
        <button class="poi-btn" data-poi="cafe">&#x2615; Caf&eacute;</button>
        <button class="poi-clear" id="poiClear" style="display:none">Wis markers</button>
    </div>

    <main>
        <h2 class="section-title">Routes <span class="route-count" id="routeCount"></span></h2>
        <div class="routes" id="routes"></div>

        <h2 class="section-title" style="margin-top:2.5rem">Tips</h2>
        <div class="tips">
            <div class="tip-card">
                <h3>&#x1F32C;&#xFE0F; Wind op dammen</h3>
                <p>Op de Brouwersdam, Oosterscheldekering en Haringvlietdam kan het flink waaien. Houd rekening met zijwind.</p>
            </div>
            <div class="tip-card">
                <h3>&#x26FD; Tanken</h3>
                <p>Op eilanden en in de Ardennen zijn tankstations spaarzaam. Vertrek altijd met een volle tank.</p>
            </div>
            <div class="tip-card">
                <h3>&#x1F338; Seizoen</h3>
                <p>Bollenstreek: half maart &ndash; half mei. Ardennen &amp; Eifel: april &ndash; oktober. Limburg is jaarrond mooi.</p>
            </div>
            <div class="tip-card">
                <h3>&#x26A0;&#xFE0F; Bergwegen</h3>
                <p>In de Ardennen, Eifel en Sauerland zijn wegen smal met blinde bochten. Rij alert, pas je snelheid aan.</p>
            </div>
            <div class="tip-card">
                <h3>&#x1F6C2; Grensverkeer</h3>
                <p>In Belgi&euml; en Duitsland gelden andere snelheidslimieten. Controleer lokale regels voor vertrek.</p>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2026 Motorroutes NL &middot; BE &middot; DE &mdash; Rij veilig, geniet van de weg <span>&hearts;</span></p>
    </footer>
</div>

<script>
// ============================================================
//  CONFIG & API ENDPOINTS (all free, no API key needed)
// ============================================================
const OSRM_URL = "https://router.project-osrm.org/route/v1/driving";
const NOMINATIM_URL = "https://nominatim.openstreetmap.org/search";
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

// ============================================================
//  DESTINATION DATABASE — cities in NL / BE / DE
// ============================================================
const destinations = [
    // Nederland
    { name: "Rotterdam", lat: 51.9244, lon: 4.4777 },
    { name: "Amsterdam", lat: 52.3676, lon: 4.9041 },
    { name: "Utrecht", lat: 52.0907, lon: 5.1214 },
    { name: "Breda", lat: 51.5719, lon: 4.7683 },
    { name: "Den Bosch", lat: 51.6998, lon: 5.3049 },
    { name: "Arnhem", lat: 51.9851, lon: 5.8987 },
    { name: "Haarlem", lat: 52.3874, lon: 4.6462 },
    { name: "Middelburg", lat: 51.4988, lon: 3.6109 },
    { name: "Leeuwarden", lat: 53.2012, lon: 5.7999 },
    { name: "Groningen", lat: 53.2194, lon: 6.5665 },
    { name: "Maastricht", lat: 50.8514, lon: 5.6910 },
    { name: "Eindhoven", lat: 51.4416, lon: 5.4697 },
    { name: "Zwolle", lat: 52.5168, lon: 6.0830 },
    { name: "Dordrecht", lat: 51.8133, lon: 4.6694 },
    { name: "Leiden", lat: 52.1601, lon: 4.4970 },
    // Belgie
    { name: "Antwerpen", lat: 51.2194, lon: 4.4025 },
    { name: "Brussel", lat: 50.8503, lon: 4.3517 },
    { name: "Gent", lat: 51.0543, lon: 3.7174 },
    { name: "Brugge", lat: 51.2093, lon: 3.2247 },
    { name: "Luik", lat: 50.6326, lon: 5.5797 },
    { name: "Namen", lat: 50.4674, lon: 4.8712 },
    // Duitsland
    { name: "Aken", lat: 50.7753, lon: 6.0839 },
    { name: "Dusseldorf", lat: 51.2277, lon: 6.7735 },
    { name: "Keulen", lat: 50.9375, lon: 6.9603 },
    { name: "Munster", lat: 51.9607, lon: 7.6261 },
    { name: "Osnabruk", lat: 52.2799, lon: 8.0472 },
    { name: "Kleve", lat: 51.7890, lon: 6.1384 },
];

// ============================================================
//  ROUTE DATA (28 routes)
// ============================================================
const routes = [
    // --- NEDERLAND (16 routes) ---
    {
        name: "Kustlijn \u2014 Hoek van Holland naar Renesse", icon: "\u{1F30A}", km: 170,
        duration: "2,5\u20133 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["kust"], country: "nl",
        waypoints: ["Maassluis","Hoek van Holland","Rockanje","Ouddorp","Brouwersdam","Renesse","Zierikzee","Haringvlietbrug","Maassluis"],
        coords: [[51.9225,4.2490],[51.9783,4.1267],[51.8731,4.0561],[51.8123,3.9323],[51.7470,3.8620],[51.7327,3.7720],[51.6505,3.9161],[51.8302,4.2120],[51.9225,4.2490]],
        highlights: ["Brouwersdam","Renesse","Zierikzee","Haringvlietbrug"],
        description: "Start bij Hoek van Holland en volg de kust zuidwaarts. Op de Brouwersdam voel je wind van twee kanten. Via Renesse naar Zierikzee, terug over de Haringvlietbrug met eindeloze luchten."
    },
    {
        name: "Vestingstad Brielle & Voorne-Putten", icon: "\u{1F3F0}", km: 100,
        duration: "2\u20132,5 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Maassluis","Brielle","Oostvoorne","Rockanje","Hellevoetsluis","Geervliet","Heenvliet","Zwartewaal","Maassluis"],
        coords: [[51.9225,4.2490],[51.9017,4.1630],[51.9103,4.0835],[51.8731,4.0561],[51.8331,4.1328],[51.8629,4.2578],[51.8687,4.2308],[51.8793,4.2085],[51.9225,4.2490]],
        highlights: ["Vestingstad Brielle","Duinen Oostvoorne","Hellevoetsluis","Geervliet"],
        description: "Smalle polderwegen tussen weilanden, historische dorpjes die de tijd vergeten zijn. Brielle is het hoogtepunt: parkeer bij de vestingwal en dwaal door de straatjes."
    },
    {
        name: "Dikke Dijken \u2014 Het beste van Zeeland", icon: "\u{1F309}", km: 200,
        duration: "3\u20134 uur", durationHours: 4, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["kust"], country: "nl",
        waypoints: ["Maassluis","Haringvlietbrug","Bruinisse","Dreischor","Zierikzee","Oosterscheldekering","Neeltje Jans","Veere","Maassluis"],
        coords: [[51.9225,4.2490],[51.8302,4.2120],[51.6647,4.0833],[51.6835,3.9563],[51.6505,3.9161],[51.6249,3.7353],[51.6262,3.7120],[51.5535,3.5950],[51.9225,4.2490]],
        highlights: ["Dreischor","Plompe Toren","Oosterscheldekering","Veere"],
        description: "De koningin van de Zeeuwse motorroutes. De Oosterscheldekering is overweldigend: 9 km staal en beton. Op Walcheren wacht het sprookjesachtige Veere."
    },
    {
        name: "Kinderdijk & Alblasserwaard", icon: "\u{1F3E1}", km: 130,
        duration: "2\u20132,5 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Maassluis","Ridderkerk","Kinderdijk","Bleskensgraaf","Schoonhoven","Gouda","Maassluis"],
        coords: [[51.9225,4.2490],[51.8721,4.6013],[51.8836,4.6363],[51.8626,4.7810],[51.9454,4.8488],[52.0115,4.7108],[51.9225,4.2490]],
        highlights: ["Kinderdijk UNESCO","Lekdijk","Zilverstad Schoonhoven","Gouda"],
        description: "Bij Kinderdijk staan 19 UNESCO-molens als wachters langs het water. De Lekdijk richting Schoonhoven biedt heerlijke bochten, Gouda sluit af met kaas en grachten."
    },
    {
        name: "Utrechtse Heuvelrug \u2014 Bossen & Bochten", icon: "\u{1F332}", km: 200,
        duration: "3,5\u20134 uur", durationHours: 4, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bos"], country: "nl",
        waypoints: ["Maassluis","Driebergen","Doorn","Amerongen","Rhenen","Wijk bij Duurstede","Gorinchem","Maassluis"],
        coords: [[51.9225,4.2490],[52.0530,5.2820],[52.0327,5.3451],[51.9940,5.4576],[51.9592,5.5684],[51.9744,5.3372],[51.8345,4.9733],[51.9225,4.2490]],
        highlights: ["Amerongse Berg","Kasteel Amerongen","Huis Doorn","Gorinchem"],
        description: "De enige route met echte hoogteverschillen. De Amerongse Berg biedt strak asfalt en verrassend hoogteverschil. D\u00e9 route voor wie bochten zoekt."
    },
    {
        name: "Eilanden \u2014 Goeree-Overflakkee", icon: "\u{1F3DD}", km: 180,
        duration: "2,5\u20133 uur", durationHours: 3, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["kust","polder"], country: "nl",
        waypoints: ["Maassluis","Hellevoetsluis","Haringvlietdam","Middelharnis","Ouddorp","Goedereede","Oude-Tonge","Willemstad","Maassluis"],
        coords: [[51.9225,4.2490],[51.8331,4.1328],[51.8403,4.0587],[51.7546,4.1694],[51.8123,3.9323],[51.8181,3.9803],[51.6926,4.2158],[51.6948,4.4357],[51.9225,4.2490]],
        highlights: ["Haringvlietdam","Kwade Hoek","Goedereede","Willemstad"],
        description: "Het vergeten eiland van Zuid-Holland. Zodra je de Haringvlietdam oversteekt, dalen tempo en stress. Goedereede verrast met middeleeuwse straatjes."
    },
    {
        name: "Dordrecht, Biesbosch & Rivierendelta", icon: "\u{1F6F6}", km: 160,
        duration: "2,5\u20133 uur", durationHours: 3, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Maassluis","Dordrecht","Werkendam","Biesbosch","Drimmelen","Hoeksche Waard","Oud-Beijerland","Maassluis"],
        coords: [[51.9225,4.2490],[51.8133,4.6694],[51.8107,4.8932],[51.7523,4.8053],[51.7044,4.7943],[51.7576,4.3958],[51.8247,4.4137],[51.9225,4.2490]],
        highlights: ["Dordrecht oudste stad","Biesbosch Museum","Overdiepse Polder","Drimmelen"],
        description: "Via Dordrecht naar de Biesbosch, waar het museum deels onder het maaiveld ligt. De Overdiepse Polder fascineert: boerderijen op terpen."
    },
    {
        name: "Bollenstreek & Duinenkust", icon: "\u{1F337}", km: 120,
        duration: "2\u20132,5 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["kust"], country: "nl",
        waypoints: ["Maassluis","Delft","Wassenaar","Katwijk","Noordwijk","Lisse","Leiden","Maassluis"],
        coords: [[51.9225,4.2490],[52.0116,4.3571],[52.1453,4.3976],[52.2008,4.3952],[52.2360,4.4430],[52.2573,4.5571],[52.1601,4.4970],[51.9225,4.2490]],
        highlights: ["Delft","Keukenhof (lente)","Noordwijk strand","Leiden"],
        description: "De vrolijkste route, ideaal voor een lenteochtend. In het voorjaar exploderen de bollenvelden in kleur \u2014 een spektakel op ooghoogte."
    },
    {
        name: "Waterland & Marken", icon: "\u{2693}", km: 95,
        duration: "2 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Amsterdam","Broek in Waterland","Monnickendam","Marken","Volendam","Edam","Amsterdam"],
        coords: [[52.3676,4.9041],[52.4326,4.9975],[52.4601,5.0363],[52.4599,5.1039],[52.4953,5.0711],[52.5132,5.0471],[52.3676,4.9041]],
        highlights: ["Marken","Volendam","Edam","Monnickendam"],
        description: "Vlak achter Amsterdam wordt het stil: weidse polders, houten huizen en vissershaventjes. Marken voelt als een ander tijdperk."
    },
    {
        name: "Noord-Hollandse Kust", icon: "\u{1F3D6}", km: 145,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["kust"], country: "nl",
        waypoints: ["Haarlem","Zandvoort","IJmuiden","Beverwijk","Castricum","Bergen","Egmond aan Zee","Haarlem"],
        coords: [[52.3874,4.6462],[52.3752,4.5339],[52.4584,4.6178],[52.4863,4.6570],[52.5454,4.6579],[52.6683,4.7069],[52.6213,4.6271],[52.3874,4.6462]],
        highlights: ["Zandvoort","Castricum duinen","Bergen kunstenaarsdorp","Egmond"],
        description: "Van Haarlem naar zee bij Zandvoort, dan noordwaarts langs de kust. Brede stranden, duinpaden en het kunstenaarsdorp Bergen."
    },
    {
        name: "Veluwe & Posbank", icon: "\u{1F33F}", km: 135,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bos"], country: "nl",
        waypoints: ["Arnhem","Posbank","Hoenderloo","Otterlo","Ede","Wageningen","Arnhem"],
        coords: [[51.9851,5.8987],[52.0356,6.0048],[52.1475,5.8931],[52.1009,5.7756],[52.0383,5.6640],[51.9692,5.6653],[51.9851,5.8987]],
        highlights: ["Posbank uitzicht","Kr\u00f6ller-M\u00fcller Museum","Otterlo","Hoge Veluwe"],
        description: "De Posbank biedt de beste bochten van midden-Nederland. Dwars door de Veluwe: heidevelden, bossen en af en toe een kudde."
    },
    {
        name: "Achterhoek Toer", icon: "\u{1F33E}", km: 110,
        duration: "2 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Doetinchem","Bronkhorst","Vorden","Lochem","Borculo","Groenlo","Doetinchem"],
        coords: [[51.9655,6.2886],[52.0643,6.1539],[52.1072,6.3125],[52.1601,6.4142],[52.1145,6.5239],[52.0442,6.6156],[51.9655,6.2886]],
        highlights: ["Bronkhorst kleinste stad","Kasteel Vorden","Lochem","Groenlo"],
        description: "Bronkhorst \u2014 het kleinste stadje van Nederland \u2014 is het hoogtepunt. Kronkelende landweggetjes en coulissenlandschap."
    },
    {
        name: "Friese Meren", icon: "\u{26F5}", km: 155,
        duration: "3 uur", durationHours: 3, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["polder"], country: "nl",
        waypoints: ["Leeuwarden","Sneek","Sloten","Lemmer","Heerenveen","Grou","Leeuwarden"],
        coords: [[53.2012,5.7999],[53.0315,5.6611],[52.8914,5.6482],[52.8459,5.7094],[52.9590,5.9249],[53.0925,5.8290],[53.2012,5.7999]],
        highlights: ["Sneek Waterpoort","Sloten vestingstad","Lemmer","Friese meren"],
        description: "Van meren naar meren, door het waterrijke hart van Friesland. Sneek, het vestingstadje Sloten en overal die eindeloze Friese luchten."
    },
    {
        name: "Zuid-Limburg Heuvelland", icon: "\u{26F0}", km: 90,
        duration: "2 uur", durationHours: 2, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "nl",
        waypoints: ["Maastricht","Gulpen","Vaals","Vijlen","Epen","Valkenburg","Maastricht"],
        coords: [[50.8514,5.6910],[50.8168,5.8864],[50.7701,6.0175],[50.7897,5.9548],[50.7695,5.9172],[50.8659,5.8322],[50.8514,5.6910]],
        highlights: ["Drielandenpunt","Gulpen","Epen","Valkenburg"],
        description: "Het dichtstbijzijnde gebergte dat we hebben. Steile hellingen, haarspeldbochten en vakwerkhuizen. Vaals bezit het Drielandenpunt."
    },
    {
        name: "Twente & Salland", icon: "\u{1F343}", km: 150,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bos"], country: "nl",
        waypoints: ["Enschede","Oldenzaal","Ootmarsum","Hardenberg","Ommen","Hellendoorn","Enschede"],
        coords: [[52.2215,6.8937],[52.3133,6.9292],[52.4105,6.8925],[52.5746,6.6186],[52.5244,6.4246],[52.3965,6.4568],[52.2215,6.8937]],
        highlights: ["Ootmarsum","Ommen","Sallandse Heuvelrug","Hellendoorn"],
        description: "Enschede tot Ootmarsum via glooiende es-landschappen en landgoederen. De Sallandse Heuvelrug biedt verrassend reli\u00ebf."
    },
    {
        name: "Brabantse Kempen", icon: "\u{1F332}", km: 110,
        duration: "2 uur", durationHours: 2, difficulty: "easy", difficultyLabel: "Beginner",
        tags: ["bos"], country: "nl",
        waypoints: ["Eindhoven","Oirschot","Hilvarenbeek","Reusel","Eersel","Valkenswaard","Eindhoven"],
        coords: [[51.4416,5.4697],[51.5058,5.3095],[51.4839,5.1359],[51.3584,5.1694],[51.3575,5.3153],[51.3513,5.4614],[51.4416,5.4697]],
        highlights: ["Oirschot","Hilvarenbeek","Reusel","Eersel"],
        description: "Rustige route door de Brabantse Kempen: dennenbossen, vennen en dorpen met gezellige terrassen."
    },
    // --- BELGI\u00CB (6 routes) ---
    {
        name: "Ardennen Serpentines", icon: "\u{1F3CE}", km: 140,
        duration: "3 uur", durationHours: 3, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "be",
        waypoints: ["Spa","Francorchamps","Stavelot","Trois-Ponts","Coo","La Gleize","Stoumont","Spa"],
        coords: [[50.4874,5.8667],[50.4443,5.9485],[50.3949,5.9310],[50.3717,5.8706],[50.3826,5.8616],[50.3987,5.8466],[50.4038,5.8122],[50.4874,5.8667]],
        highlights: ["Spa-Francorchamps","Cascade de Coo","La Gleize","Stavelot"],
        description: "Het circuit van Spa-Francorchamps als startpunt voor de meest uitdagende bochten van de Benelux. Steil, smal en spectaculair."
    },
    {
        name: "Hoge Venen", icon: "\u{1F32B}", km: 120,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bergen"], country: "be",
        waypoints: ["Eupen","Baraque Michel","Signal de Botrange","Malmedy","Robertville","B\u00fctgenbach","Eupen"],
        coords: [[50.6278,6.0326],[50.5050,6.0770],[50.5022,6.0897],[50.4270,5.9810],[50.4540,6.1060],[50.4270,6.2150],[50.6278,6.0326]],
        highlights: ["Signal de Botrange (694m)","Hoge Venen","Malmedy","Robertville"],
        description: "Het hoogste punt van Belgi\u00eb via mistige hoogvlaktes. De Signal de Botrange (694m) en het pittoreske Malmedy."
    },
    {
        name: "Maasvallei \u2014 Dinant & Hasti\u00e8re", icon: "\u{1F3DE}", km: 150,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bergen"], country: "be",
        waypoints: ["Namur","Dinant","Hasti\u00e8re","Givet","Viroinval","Philippeville","Namur"],
        coords: [[50.4674,4.8712],[50.2610,4.9120],[50.2150,4.8340],[50.1370,4.8240],[50.0650,4.5390],[50.1955,4.5440],[50.4674,4.8712]],
        highlights: ["Citadel Dinant","Maasvallei","Viroinval","Philippeville"],
        description: "De Maas kronkelt diep door het landschap bij Dinant en Hasti\u00e8re. Citadellen, grotten en indrukwekkende rotsformaties."
    },
    {
        name: "Luxemburgse Ardennen", icon: "\u{1F3D4}", km: 250,
        duration: "5 uur", durationHours: 5, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "be",
        waypoints: ["Bastogne","Houffalize","La Roche-en-Ardenne","Marche-en-Famenne","Nassogne","Saint-Hubert","Bastogne"],
        coords: [[50.0000,5.7167],[50.1311,5.7906],[50.1833,5.5750],[50.2269,5.3442],[50.1286,5.3450],[50.0564,5.3750],[50.0000,5.7167]],
        highlights: ["Bastogne oorlogshistorie","La Roche kasteel","Saint-Hubert","Houffalize"],
        description: "De meest afgelegen hoek van Belgi\u00eb. Dichte bossen, diepe valleien en nauwelijks verkeer. Houffalize en La Roche zijn sprookjesachtig."
    },
    {
        name: "Vlaamse Heuvelroute", icon: "\u{1F6B4}", km: 90,
        duration: "2 uur", durationHours: 2, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bergen"], country: "be",
        waypoints: ["Oudenaarde","Kluisbergen","Ronse","Geraardsbergen","Zottegem","Brakel","Oudenaarde"],
        coords: [[50.8465,3.6022],[50.7771,3.5128],[50.7500,3.6000],[50.7710,3.8800],[50.8699,3.8101],[50.8084,3.7379],[50.8465,3.6022]],
        highlights: ["Koppenberg","Muur van Geraardsbergen","Kluisberg","Ronse"],
        description: "De hellingen van de Vlaamse wielrennersklassiekers, nu op twee wielen met motor. Kort maar krachtig \u2014 steil en onvergetelijk."
    },
    {
        name: "Drie Landen Route", icon: "\u{1F1EA}\u{1F1FA}", km: 160,
        duration: "3 uur", durationHours: 3, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "be",
        waypoints: ["Vaals","Aachen","Monschau","Malmedy","Spa","Henri-Chapelle","Vaals"],
        coords: [[50.7701,6.0175],[50.7753,6.0839],[50.5555,6.2424],[50.4270,5.9810],[50.4874,5.8667],[50.6702,5.8958],[50.7701,6.0175]],
        highlights: ["Drielandenpunt","Monschau","Malmedy","Spa"],
        description: "In \u00e9\u00e9n rit door Nederland, Belgi\u00eb en Duitsland. Van Vaals naar het middeleeuwse Monschau, via Malmedy terug."
    },
    // --- DUITSLAND (6 routes) ---
    {
        name: "Eifel Vulkaanroute", icon: "\u{1F30B}", km: 150,
        duration: "3 uur", durationHours: 3, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "de",
        waypoints: ["N\u00fcrburg","Adenau","Gerolstein","Daun","Manderscheid","Ulmen","N\u00fcrburg"],
        coords: [[50.3437,6.9458],[50.3820,6.9355],[50.2224,6.6603],[50.1973,6.8298],[50.0981,6.8091],[50.2085,6.9745],[50.3437,6.9458]],
        highlights: ["N\u00fcrburgring","Gerolstein","Dauner Maare","Manderscheid"],
        description: "De N\u00fcrburgring als vertrekpunt voor vulkaanmeren en kronkelende Eifelwegen. Gerolstein en Manderscheid zijn verborgen parels."
    },
    {
        name: "Sauerland Kurven", icon: "\u{1F3D4}", km: 140,
        duration: "3 uur", durationHours: 3, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "de",
        waypoints: ["Winterberg","Willingen","Brilon","Meschede","Eslohe","Schmallenberg","Winterberg"],
        coords: [[51.1952,8.5268],[51.2935,8.6107],[51.3938,8.5720],[51.3504,8.2832],[51.2551,8.1660],[51.1529,8.2895],[51.1952,8.5268]],
        highlights: ["Winterberg","Willingen","Schmallenberg","Eslohe"],
        description: "Winterberg is het startpunt van eindeloze bochtencombinaties door het Sauerland. Motorrijders noemen dit 'Klein Alpen'."
    },
    {
        name: "Mosel Traumstra\u00dfe", icon: "\u{1F347}", km: 130,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bergen"], country: "de",
        waypoints: ["Cochem","Beilstein","Zell","Traben-Trarbach","Bernkastel-Kues","Alf","Cochem"],
        coords: [[50.1469,7.1671],[50.1080,7.2370],[50.0270,7.1820],[49.9480,7.1160],[49.9150,7.0670],[50.0530,7.1280],[50.1469,7.1671]],
        highlights: ["Cochem Reichsburg","Beilstein","Bernkastel-Kues","Moselwijn"],
        description: "De Mosel slingert tussen steile wijngaarden. Van Cochem naar Bernkastel-Kues \u2014 elke bocht onthult een nieuw kasteel."
    },
    {
        name: "Schwarzwald Hochstra\u00dfe", icon: "\u{1F332}", km: 240,
        duration: "5 uur", durationHours: 5, difficulty: "advanced", difficultyLabel: "Gevorderd",
        tags: ["bergen"], country: "de",
        waypoints: ["Baden-Baden","B\u00fchl","Mummelsee","Freudenstadt","Alpirsbach","Gengenbach","Baden-Baden"],
        coords: [[48.7606,8.2405],[48.6966,8.1364],[48.5956,8.2013],[48.4618,8.4109],[48.3454,8.4027],[48.4044,8.0145],[48.7606,8.2405]],
        highlights: ["Schwarzwaldhochstra\u00dfe","Mummelsee","Freudenstadt","Gengenbach"],
        description: "De beroemde Schwarzwaldhochstra\u00dfe van Baden-Baden tot Freudenstadt. Haarspeldbochten, mysterieuze bossen en het Mummelsee."
    },
    {
        name: "Weserbergland", icon: "\u{1F3F0}", km: 150,
        duration: "3 uur", durationHours: 3, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bos"], country: "de",
        waypoints: ["Hameln","Bodenwerder","H\u00f6xter","Beverungen","Bad Karlshafen","Polle","Hameln"],
        coords: [[52.1042,9.3576],[51.9739,9.5213],[51.7753,9.3803],[51.6649,9.3725],[51.6443,9.4564],[51.9087,9.4044],[52.1042,9.3576]],
        highlights: ["Hameln Rattenvanger","M\u00fcnchhausen Museum","H\u00f6xter","Weser rivier"],
        description: "Rattenvanger van Hameln als vertrekpunt door het Weserbergland. Heuvelachtig, groen en verrassend rustig."
    },
    {
        name: "Teutoburger Wald", icon: "\u{1FAA8}", km: 115,
        duration: "2 uur", durationHours: 2, difficulty: "medium", difficultyLabel: "Gemiddeld",
        tags: ["bos"], country: "de",
        waypoints: ["Detmold","Externsteine","Horn-Bad Meinberg","Schieder","Blomberg","Lemgo","Detmold"],
        coords: [[51.9374,8.8794],[51.8683,8.9174],[51.8836,8.9691],[51.8961,9.1624],[51.9427,9.0904],[52.0291,8.9020],[51.9374,8.8794]],
        highlights: ["Externsteine","Hermannsdenkmal","Lemgo","Blomberg"],
        description: "De mysterieuze Externsteine en dichte beukenbossen. Compact maar avontuurlijk door het Teutoburgerwoud."
    }
];

// ============================================================
//  UTILITIES
// ============================================================
const countryFlags = { nl: "\u{1F1F3}\u{1F1F1}", be: "\u{1F1E7}\u{1F1EA}", de: "\u{1F1E9}\u{1F1EA}" };
const diffColors = { easy: "#2ed573", medium: "#ffa502", advanced: "#ff4757", generated: "#4285f4" };
const countryNames = { nl: "Netherlands", be: "Belgium", de: "Germany" };

// Postcode fallback lookup (used when Nominatim is unavailable)
const postcodeFallback = {
    nl: { '1':[52.37,4.89],'2':[52.07,4.30],'3':[51.92,4.48],'4':[51.50,4.30],'5':[51.44,5.47],'6':[51.20,5.98],'7':[52.22,6.15],'8':[52.52,5.47],'9':[53.10,6.20] },
    be: { '1':[50.85,4.35],'2':[51.22,4.40],'3':[50.93,5.33],'4':[50.63,5.57],'5':[50.47,4.87],'6':[50.00,5.72],'7':[50.45,3.95],'8':[51.05,3.10],'9':[51.05,3.73] },
    de: { '0':[51.05,13.74],'1':[52.52,13.41],'2':[53.55,9.99],'3':[52.37,9.74],'4':[51.45,7.01],'5':[50.94,6.96],'6':[50.11,8.68],'7':[48.78,9.18],'8':[48.14,11.58],'9':[49.45,11.08] }
};

function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function downsample(coords, maxPoints) {
    if (coords.length <= maxPoints) return coords;
    const step = (coords.length - 1) / (maxPoints - 1);
    const result = [];
    for (let i = 0; i < maxPoints; i++) result.push(coords[Math.round(i * step)]);
    return result;
}

function pointToSegmentDist(p, a, b) {
    const dx = b[0]-a[0], dy = b[1]-a[1];
    if (dx===0 && dy===0) return haversine(p[0],p[1],a[0],a[1]);
    let t = ((p[0]-a[0])*dx + (p[1]-a[1])*dy) / (dx*dx + dy*dy);
    t = Math.max(0, Math.min(1, t));
    return haversine(p[0], p[1], a[0]+t*dx, a[1]+t*dy);
}

// ============================================================
//  RATE LIMITER
// ============================================================
class RateLimiter {
    constructor(ms) { this.ms = ms; this.last = 0; }
    async wait() {
        const now = Date.now(), d = now - this.last;
        if (d < this.ms) await new Promise(r => setTimeout(r, this.ms - d));
        this.last = Date.now();
    }
}
const osrmLimiter = new RateLimiter(1100);
const overpassLimiter = new RateLimiter(3000);
const nominatimLimiter = new RateLimiter(1100);

// ============================================================
//  CACHES
// ============================================================
const routeGeomCache = new Map();
const poiCache = new Map();
const geocodeCache = new Map();

// ============================================================
//  GEOCODING (Nominatim, fallback to hardcoded)
// ============================================================
async function geocodePostcode(postcode, country) {
    const key = `${country}:${postcode}`;
    if (geocodeCache.has(key)) return geocodeCache.get(key);

    const clean = postcode.replace(/\s/g, '').toUpperCase();
    if (!clean) return null;

    try {
        await nominatimLimiter.wait();
        const url = `${NOMINATIM_URL}?postalcode=${encodeURIComponent(clean)}&country=${encodeURIComponent(countryNames[country])}&format=json&limit=1`;
        const resp = await fetch(url, { headers: { 'User-Agent': 'MotorroutesNLBEDE/1.0' } });
        const data = await resp.json();
        if (data.length > 0) {
            const coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
            geocodeCache.set(key, coords);
            return coords;
        }
    } catch (e) {
        console.warn("Nominatim failed, using fallback:", e);
    }

    // Fallback
    const table = postcodeFallback[country];
    if (table && table[clean[0]]) {
        const coords = table[clean[0]];
        geocodeCache.set(key, coords);
        return coords;
    }
    return null;
}

// ============================================================
//  ROUTING (OSRM)
// ============================================================
async function fetchRouteGeometry(coordsLatLon) {
    // coordsLatLon = [[lat,lon], ...]
    const cacheKey = coordsLatLon.map(c => `${c[0].toFixed(4)},${c[1].toFixed(4)}`).join('|');
    if (routeGeomCache.has(cacheKey)) return routeGeomCache.get(cacheKey);

    await osrmLimiter.wait();

    // OSRM wants lon,lat
    const coordStr = coordsLatLon.map(c => `${c[1]},${c[0]}`).join(';');
    const url = `${OSRM_URL}/${coordStr}?overview=full&geometries=geojson`;

    const resp = await fetch(url);
    const data = await resp.json();

    if (data.code === "Ok" && data.routes && data.routes.length > 0) {
        // Convert [lon,lat] back to [lat,lon] for Leaflet
        const geom = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
        const result = {
            geometry: geom,
            distance: data.routes[0].distance,
            duration: data.routes[0].duration
        };
        routeGeomCache.set(cacheKey, result);
        return result;
    }
    return null;
}

// ============================================================
//  POI SEARCH (Overpass)
// ============================================================
const poiTypes = {
    fuel:       { tag: '"amenity"="fuel"', emoji: '\u26FD', label: 'Benzinepomp' },
    fast_food:  { tag: '"amenity"="fast_food"', emoji: '\u{1F35F}', label: 'Cafetaria' },
    restaurant: { tag: '"amenity"="restaurant"', emoji: '\u{1F37D}\uFE0F', label: 'Restaurant' },
    cafe:       { tag: '"amenity"="cafe"', emoji: '\u2615', label: 'Caf\u00e9' }
};

async function searchPOIsAlongRoute(routeGeometry, poiType, radius) {
    radius = radius || 2000;
    const cacheKey = `${poiType}:${routeGeometry.length}:${routeGeometry[0][0].toFixed(3)}`;
    if (poiCache.has(cacheKey)) return poiCache.get(cacheKey);

    await overpassLimiter.wait();

    const sampled = downsample(routeGeometry, 20);
    const coordStr = sampled.map(c => `${c[0]},${c[1]}`).join(',');
    const tag = poiTypes[poiType].tag;

    const query = `[out:json][timeout:25];(node[${tag}](around:${radius},${coordStr});way[${tag}](around:${radius},${coordStr}););out center body;`;

    const resp = await fetch(OVERPASS_URL, {
        method: 'POST',
        body: 'data=' + encodeURIComponent(query)
    });
    const data = await resp.json();

    const pois = data.elements.map(el => ({
        name: el.tags?.name || poiTypes[poiType].label,
        lat: el.lat || el.center?.lat,
        lon: el.lon || el.center?.lon,
        brand: el.tags?.brand || '',
        address: [el.tags?.['addr:street'], el.tags?.['addr:housenumber']].filter(Boolean).join(' '),
        city: el.tags?.['addr:city'] || '',
        opening_hours: el.tags?.opening_hours || '',
        phone: el.tags?.phone || '',
        website: el.tags?.website || '',
        cuisine: el.tags?.cuisine || ''
    })).filter(p => p.lat && p.lon);

    poiCache.set(cacheKey, pois);
    return pois;
}

// ============================================================
//  ATTRACTION SEARCH (Overpass)
// ============================================================
async function searchAttractionsAlongRoute(routeGeometry) {
    const cacheKey = `attractions:${routeGeometry.length}:${routeGeometry[0][0].toFixed(3)}`;
    if (poiCache.has(cacheKey)) return poiCache.get(cacheKey);

    await overpassLimiter.wait();

    const sampled = downsample(routeGeometry, 15);
    const coordStr = sampled.map(c => `${c[0]},${c[1]}`).join(',');

    const query = `[out:json][timeout:25];(
        node["historic"="castle"](around:3000,${coordStr});
        node["historic"="monument"](around:3000,${coordStr});
        node["historic"="bunker"](around:3000,${coordStr});
        node["man_made"="windmill"](around:3000,${coordStr});
        node["tourism"="viewpoint"](around:3000,${coordStr});
        way["historic"="castle"](around:3000,${coordStr});
        way["man_made"="windmill"](around:3000,${coordStr});
    );out center body;`;

    const resp = await fetch(OVERPASS_URL, {
        method: 'POST',
        body: 'data=' + encodeURIComponent(query)
    });
    const data = await resp.json();

    const typeEmoji = {
        castle: '\u{1F3F0}', monument: '\u{1F3DB}\uFE0F', bunker: '\u{1FAA8}',
        windmill: '\u{1F32C}\uFE0F', viewpoint: '\u{1F52D}'
    };
    const typeLabel = {
        castle: 'Kasteel', monument: 'Monument', bunker: 'Bunker',
        windmill: 'Molen', viewpoint: 'Uitzichtpunt'
    };

    const attractions = data.elements.map(el => {
        const t = el.tags?.historic || el.tags?.man_made || el.tags?.tourism || 'monument';
        return {
            name: el.tags?.name || typeLabel[t] || 'Bezienswaardigheid',
            lat: el.lat || el.center?.lat,
            lon: el.lon || el.center?.lon,
            type: t,
            emoji: typeEmoji[t] || '\u{1F3DB}\uFE0F',
            description: el.tags?.description || el.tags?.['description:nl'] || ''
        };
    }).filter(a => a.lat && a.lon);

    poiCache.set(cacheKey, attractions);
    return attractions;
}

// ============================================================
//  ROUTE GENERATION FROM POSTCODE
// ============================================================
async function generateRouteFromPostcode(startCoords, durationHours) {
    setStatus("Zoeken naar bezienswaardigheden...");

    // Calculate loop dimensions based on ride time
    // ~55 km/h on secondary roads, loop perimeter = total km
    const totalKm = durationHours * 55;
    const radiusKm = totalKm / (2 * Math.PI) * 1.2;
    const radiusM = Math.min(radiusKm * 1000, 50000);
    const numWP = Math.min(4 + Math.floor(durationHours), 8);

    // Search for interesting POIs to route through
    let pois = [];
    try {
        await overpassLimiter.wait();
        const query = `[out:json][timeout:30];(
            node["historic"="castle"](around:${radiusM},${startCoords[0]},${startCoords[1]});
            node["historic"="monument"](around:${radiusM},${startCoords[0]},${startCoords[1]});
            node["man_made"="windmill"](around:${radiusM},${startCoords[0]},${startCoords[1]});
            node["tourism"="viewpoint"](around:${radiusM},${startCoords[0]},${startCoords[1]});
            node["tourism"="attraction"](around:${radiusM},${startCoords[0]},${startCoords[1]});
            way["historic"="castle"](around:${radiusM},${startCoords[0]},${startCoords[1]});
        );out center body;`;

        const resp = await fetch(OVERPASS_URL, {
            method: 'POST',
            body: 'data=' + encodeURIComponent(query)
        });
        const data = await resp.json();

        pois = data.elements
            .map(el => ({
                name: el.tags?.name || '',
                lat: el.lat || el.center?.lat,
                lon: el.lon || el.center?.lon,
                type: el.tags?.historic || el.tags?.man_made || el.tags?.tourism || ''
            }))
            .filter(p => p.lat && p.lon && p.name);

        // Remove POIs too close to each other (< 2 km)
        pois = pois.filter((p, i, arr) => {
            for (let j = 0; j < i; j++) {
                if (haversine(p.lat, p.lon, arr[j].lat, arr[j].lon) < 2) return false;
            }
            return true;
        });
    } catch (e) {
        console.warn("Overpass query failed, using geometric loop:", e);
    }

    // Build loop waypoints — key: evenly spaced angles around center
    // This guarantees a proper loop, never backtracking
    setStatus("Route samenstellen...");

    // Pick a random starting direction so each generation is different
    const startAngle = Math.random() * 2 * Math.PI;
    const angles = [];
    for (let i = 0; i < numWP; i++) {
        angles.push(startAngle + (2 * Math.PI * i) / numWP);
    }

    // For each angle sector, try to find a POI nearby, otherwise use a geometric point
    const loopPoints = [];
    const loopNames = [];
    const usedPOIs = new Set();

    for (const angle of angles) {
        // Target point on the loop circle
        const targetLat = startCoords[0] + (radiusKm / 111) * Math.cos(angle);
        const targetLon = startCoords[1] + (radiusKm / (111 * Math.cos(startCoords[0] * Math.PI / 180))) * Math.sin(angle);

        // Find closest unused POI within 40% of radius from this target
        let bestPOI = null;
        let bestDist = radiusKm * 0.4;
        for (const p of pois) {
            if (usedPOIs.has(p)) continue;
            const d = haversine(targetLat, targetLon, p.lat, p.lon);
            // Also check it's not too close to start (at least 3 km away)
            const distFromStart = haversine(startCoords[0], startCoords[1], p.lat, p.lon);
            if (d < bestDist && distFromStart > 3) {
                bestDist = d;
                bestPOI = p;
            }
        }

        if (bestPOI) {
            loopPoints.push([bestPOI.lat, bestPOI.lon]);
            loopNames.push(bestPOI.name);
            usedPOIs.add(bestPOI);
        } else {
            // Use geometric point (slightly varied radius for natural shape)
            const r = radiusKm * (0.75 + Math.random() * 0.35);
            const lat = startCoords[0] + (r / 111) * Math.cos(angle);
            const lon = startCoords[1] + (r / (111 * Math.cos(startCoords[0] * Math.PI / 180))) * Math.sin(angle);
            loopPoints.push([lat, lon]);
            loopNames.push(`Via ${(angle * 180 / Math.PI % 360).toFixed(0)}\u00b0`);
        }
    }

    // Build final waypoint array: Start -> loop points -> Start
    const waypoints = [startCoords, ...loopPoints, startCoords];
    const waypointNames = ["Start", ...loopNames, "Start"];

    // Fetch actual road route via OSRM
    setStatus("Route berekenen over wegen...");
    const routeData = await fetchRouteGeometry(waypoints);

    if (!routeData) {
        setStatus("Kon geen route berekenen. Probeer een andere postcode.");
        return null;
    }

    const distKm = Math.round(routeData.distance / 1000);
    const durH = Math.round(routeData.duration / 3600 * 10) / 10;
    const namedWP = waypointNames.filter(n => n !== "Start" && !n.startsWith("Via "));

    return {
        name: `Jouw route \u2014 ${distKm} km rondje`,
        icon: "\u{1F6E3}\uFE0F",
        km: distKm,
        duration: `~${durH} uur`,
        durationHours: Math.ceil(durH),
        difficulty: "generated",
        difficultyLabel: "Gegenereerd",
        tags: [],
        country: selectedCountry,
        waypoints: waypointNames,
        coords: waypoints,
        highlights: namedWP.length > 0 ? namedWP : ["Binnenwegen", "Rondje"],
        description: `Een motorroute van ${distKm} km als rondje vanaf jouw postcode.${namedWP.length > 0 ? " Via " + namedWP.join(", ") + "." : ""} De route volgt binnenwegen en keert via een andere weg terug.`,
        _generatedGeometry: routeData.geometry,
        _isGenerated: true
    };
}

// ============================================================
//  LAND CHECK — prevent waypoints in the North Sea / water
// ============================================================
function isLikelyLand(lat, lon) {
    if (lat < 46.5 || lat > 55.5) return false;
    if (lon < 2.5 || lon > 15.5) return false;

    // Dutch coast — per latitude band, minimum longitude for land
    // Goes from south (Zeeland) to north (Wadden)
    if (lat > 51.0 && lat <= 51.5 && lon < 3.3) return false;  // Zeeland / Westerschelde
    if (lat > 51.5 && lat <= 51.7 && lon < 3.6) return false;  // Goeree-Overflakkee
    if (lat > 51.7 && lat <= 52.0 && lon < 3.9) return false;  // Hoek van Holland / Maasvlakte
    if (lat > 52.0 && lat <= 52.3 && lon < 4.2) return false;  // Katwijk / Noordwijk
    if (lat > 52.3 && lat <= 52.55 && lon < 4.4) return false;  // Zandvoort / IJmuiden
    if (lat > 52.55 && lat <= 52.75 && lon < 4.55) return false; // Egmond / Bergen aan Zee
    if (lat > 52.75 && lat <= 53.0 && lon < 4.7) return false;  // Den Helder / kop NH
    if (lat > 53.0 && lat <= 53.4 && lon < 5.0) return false;  // Waddeneilanden west
    if (lat > 53.4 && lon < 6.0) return false;                  // Wadden Sea / boven Friesland
    if (lat > 54.5 && lon < 9.0) return false;                  // North Sea noord Duitsland

    // IJsselmeer / Markermeer
    if (lon > 4.9 && lon < 5.55 && lat > 52.4 && lat < 52.95) return false;

    // Westerschelde (estuarium)
    if (lat > 51.32 && lat < 51.46 && lon > 3.35 && lon < 4.05) return false;

    // Oosterschelde
    if (lat > 51.52 && lat < 51.66 && lon > 3.6 && lon < 4.15) return false;

    // Grevelingenmeer / Haringvliet mond
    if (lat > 51.7 && lat < 51.82 && lon > 3.8 && lon < 4.2) return false;

    // Belgian coast
    if (lat > 51.0 && lat <= 51.4 && lon < 2.9) return false;

    return true;
}

function snapToLand(lat, lon, centerLat, centerLon) {
    if (isLikelyLand(lat, lon)) return [lat, lon];
    // Point is in water — try pulling toward center in small steps
    let sLat = lat, sLon = lon;
    for (let i = 0; i < 10; i++) {
        sLat = sLat + (centerLat - sLat) * 0.3;
        sLon = sLon + (centerLon - sLon) * 0.3;
        if (isLikelyLand(sLat, sLon)) return [sLat, sLon];
    }
    // Still in water — also try shifting east (away from North Sea)
    sLat = lat; sLon = lon;
    for (let i = 0; i < 8; i++) {
        sLon += 0.08;
        if (isLikelyLand(sLat, sLon)) return [sLat, sLon];
    }
    // Last resort: return center (which should be on land)
    return [centerLat, centerLon];
}

// ============================================================
//  ROBUST LOOP ROUTE GENERATOR
//  Creates a loop with many intermediate waypoints (~every 12km)
//  so OSRM is forced onto 60/80 secondary roads, not highways.
//  Waypoints are checked against land boundaries.
// ============================================================
async function generateLoopRoute(startCoords, durationHours, angleOffset) {
    const totalKm = durationHours * 55;
    // Road distance ≈ straight-line × 1.2, so shrink radius to compensate
    const radiusKm = totalKm / (2 * Math.PI * 1.2);

    // ~1 waypoint per 12 km forces OSRM onto secondary roads
    const numWP = Math.max(6, Math.round(totalKm / 12));
    const cappedWP = Math.min(numWP, 20);

    const directions = [
        "Noord", "Noordoost", "Oost", "Zuidoost",
        "Zuid", "Zuidwest", "West", "Noordwest"
    ];
    const dirIdx = Math.round(((angleOffset % (2*Math.PI)) / (2*Math.PI)) * 8) % 8;
    const dirLabel = directions[dirIdx];
    const icons = ["\u{1F6E3}\uFE0F", "\u{1F3CD}\uFE0F", "\u{1F30A}", "\u{1F332}", "\u{1F33F}", "\u{26F0}\uFE0F"];
    const icon = icons[dirIdx % icons.length];

    const waypoints = [startCoords];
    for (let i = 0; i < cappedWP; i++) {
        const angle = angleOffset + (2 * Math.PI * i) / cappedWP;
        const wobble = 0.85 + (Math.sin(angle * 3) * 0.15);
        const r = radiusKm * wobble;
        let lat = startCoords[0] + (r / 111) * Math.cos(angle);
        let lon = startCoords[1] + (r / (111 * Math.cos(startCoords[0] * Math.PI / 180))) * Math.sin(angle);
        // Snap to land if in water
        [lat, lon] = snapToLand(lat, lon, startCoords[0], startCoords[1]);
        waypoints.push([lat, lon]);
    }
    waypoints.push(startCoords);

    const routeData = await fetchRouteGeometry(waypoints);
    if (!routeData) return null;

    const distKm = Math.round(routeData.distance / 1000);
    const durH = Math.round(routeData.duration / 3600 * 10) / 10;

    const waypointNames = ["Start"];
    for (let i = 0; i < cappedWP; i++) waypointNames.push(`Via ${dirLabel} ${i+1}`);
    waypointNames.push("Start");

    return {
        name: `Rondje ${dirLabel} (${distKm} km)`,
        icon: icon,
        km: distKm,
        duration: `~${durH} uur`,
        durationHours: durationHours,
        difficulty: durationHours <= 2 ? "easy" : durationHours <= 3 ? "medium" : "advanced",
        difficultyLabel: durationHours <= 2 ? "Beginner" : durationHours <= 3 ? "Gemiddeld" : "Gevorderd",
        tags: [],
        country: selectedCountry,
        waypoints: waypointNames,
        coords: waypoints,
        highlights: [`Richting ${dirLabel}`, "Binnenwegen", "60/80 wegen"],
        description: `Een rondje van ${distKm} km richting ${dirLabel.toLowerCase()} over binnenwegen. De route vermijdt snelwegen en volgt 60/80 km wegen. Geschatte rijtijd: ~${durH} uur.`,
        _generatedGeometry: routeData.geometry,
        _isGenerated: true
    };
}

// ============================================================
//  DESTINATION ROUTE GENERATOR
//  Goes to a city and returns via a different road.
//  Shape: elongated oval (outbound above, return below the direct line)
// ============================================================
async function generateDestinationRoute(startCoords, durationHours, direction) {
    // Target one-way STRAIGHT LINE distance
    // Total route = 2 × straight × roadFactor(~1.3) × offsetDetour(~1.1)
    // So straight = totalKm / (2 × 1.3 × 1.1) ≈ totalKm / 2.86
    const totalKm = durationHours * 55;
    const targetDistKm = totalKm / 2.9;
    const cosLat = Math.cos(startCoords[0] * Math.PI / 180);

    // Find best destination: closest to targetDistKm in roughly the right direction
    let bestDest = null;
    let bestScore = Infinity;
    for (const dest of destinations) {
        const dLat = dest.lat - startCoords[0];
        const dLon = (dest.lon - startCoords[1]) * cosLat;
        const distKm = Math.sqrt(dLat * dLat + dLon * dLon) * 111;
        const angle = Math.atan2(dLon, dLat);
        let angleDiff = Math.abs(angle - direction);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
        // Penalize wrong direction and wrong distance
        const distPenalty = Math.abs(distKm - targetDistKm) / targetDistKm;
        const anglePenalty = angleDiff / Math.PI;
        const score = distPenalty + anglePenalty * 0.6;
        if (score < bestScore) {
            bestScore = score;
            bestDest = { ...dest, distKm, angle };
        }
    }

    if (!bestDest) return null;

    // Calculate perpendicular offset for heen/terug split (~5-10 km, small enough to avoid water)
    const offsetKm = Math.min(10, Math.max(4, bestDest.distKm * 0.08));
    const perpAngle = bestDest.angle + Math.PI / 2; // perpendicular to direct line

    const destCoords = [bestDest.lat, bestDest.lon];
    const numWPperSide = Math.max(2, Math.round(bestDest.distKm / 25));

    // Generate outbound waypoints (offset above direct line)
    const outboundWP = [];
    for (let i = 1; i <= numWPperSide; i++) {
        const t = i / (numWPperSide + 1);
        // Point along direct line
        let lat = startCoords[0] + (destCoords[0] - startCoords[0]) * t;
        let lon = startCoords[1] + (destCoords[1] - startCoords[1]) * t;
        // Offset perpendicular (bulge in middle, less at ends)
        const bulge = Math.sin(t * Math.PI) * offsetKm;
        lat += (bulge / 111) * Math.cos(perpAngle);
        lon += (bulge / (111 * cosLat)) * Math.sin(perpAngle);
        [lat, lon] = snapToLand(lat, lon, startCoords[0], startCoords[1]);
        outboundWP.push([lat, lon]);
    }

    // Generate return waypoints (offset below direct line)
    const returnWP = [];
    for (let i = numWPperSide; i >= 1; i--) {
        const t = i / (numWPperSide + 1);
        let lat = startCoords[0] + (destCoords[0] - startCoords[0]) * t;
        let lon = startCoords[1] + (destCoords[1] - startCoords[1]) * t;
        const bulge = Math.sin(t * Math.PI) * offsetKm;
        lat -= (bulge / 111) * Math.cos(perpAngle);
        lon -= (bulge / (111 * cosLat)) * Math.sin(perpAngle);
        [lat, lon] = snapToLand(lat, lon, startCoords[0], startCoords[1]);
        returnWP.push([lat, lon]);
    }

    // Build full waypoint list: Start → outbound → Destination → return → Start
    const waypoints = [startCoords, ...outboundWP, destCoords, ...returnWP, startCoords];

    const routeData = await fetchRouteGeometry(waypoints);
    if (!routeData) return null;

    const distKm = Math.round(routeData.distance / 1000);
    const durH = Math.round(routeData.duration / 3600 * 10) / 10;

    const waypointNames = ["Start"];
    outboundWP.forEach((_, i) => waypointNames.push(`Heen ${i + 1}`));
    waypointNames.push(bestDest.name);
    returnWP.forEach((_, i) => waypointNames.push(`Terug ${i + 1}`));
    waypointNames.push("Start");

    return {
        name: `Rit naar ${bestDest.name} (${distKm} km)`,
        icon: "\uD83D\uDCCD",
        km: distKm,
        duration: `~${durH} uur`,
        durationHours: durationHours,
        difficulty: durationHours <= 2 ? "easy" : durationHours <= 3 ? "medium" : "advanced",
        difficultyLabel: durationHours <= 2 ? "Beginner" : durationHours <= 3 ? "Gemiddeld" : "Gevorderd",
        tags: [],
        country: selectedCountry,
        waypoints: waypointNames,
        coords: waypoints,
        highlights: [`Bestemming: ${bestDest.name}`, "Heenweg via binnenwegen", "Terugweg via andere route"],
        description: `Rit naar ${bestDest.name} en terug via een andere weg. Totaal ${distKm} km over binnenwegen. De heenweg en terugweg lopen bewust apart voor meer variatie. Geschatte rijtijd: ~${durH} uur.`,
        _generatedGeometry: routeData.geometry,
        _isGenerated: true
    };
}

// ============================================================
//  TRIANGLE ROUTE GENERATOR
//  3 points at equal distance forming a triangle.
//  Broader range than a circle, feels like a "tour".
// ============================================================
async function generateTriangleRoute(startCoords, durationHours, rotation) {
    const totalKm = durationHours * 55;
    // Triangle: Start→A (radius r) + A→B (r×√3) + B→Start (radius r) = r×(2+√3)
    // Road distance ≈ straight × 1.3, so: totalKm = r × (2+√3) × 1.3
    // r = totalKm / ((2 + √3) × 1.3) ≈ totalKm / 4.85
    const radiusKm = totalKm / 4.85;
    const cosLat = Math.cos(startCoords[0] * Math.PI / 180);

    // Calculate triangle vertices at distance radiusKm from start
    const pointA = [
        startCoords[0] + (radiusKm / 111) * Math.cos(rotation),
        startCoords[1] + (radiusKm / (111 * cosLat)) * Math.sin(rotation)
    ];
    const pointB = [
        startCoords[0] + (radiusKm / 111) * Math.cos(rotation + (2 * Math.PI / 3)),
        startCoords[1] + (radiusKm / (111 * cosLat)) * Math.sin(rotation + (2 * Math.PI / 3))
    ];

    // Snap vertices to land
    const [aLat, aLon] = snapToLand(pointA[0], pointA[1], startCoords[0], startCoords[1]);
    const [bLat, bLon] = snapToLand(pointB[0], pointB[1], startCoords[0], startCoords[1]);

    // Find nearest city names for the vertices (for labeling)
    function nearestCity(lat, lon) {
        let best = null, bestDist = Infinity;
        for (const d of destinations) {
            const dist = Math.sqrt(Math.pow(d.lat - lat, 2) + Math.pow((d.lon - lon) * cosLat, 2)) * 111;
            if (dist < bestDist) { bestDist = dist; best = d.name; }
        }
        return best;
    }
    const cityA = nearestCity(aLat, aLon);
    const cityB = nearestCity(bLat, bLon);

    // Generate intermediate waypoints along each side (~every 15 km)
    function intermediatePoints(from, to) {
        const d = Math.sqrt(Math.pow(to[0] - from[0], 2) + Math.pow((to[1] - from[1]) * cosLat, 2)) * 111;
        const n = Math.max(1, Math.round(d / 15));
        const pts = [];
        for (let i = 1; i < n; i++) {
            const t = i / n;
            let lat = from[0] + (to[0] - from[0]) * t;
            let lon = from[1] + (to[1] - from[1]) * t;
            [lat, lon] = snapToLand(lat, lon, startCoords[0], startCoords[1]);
            pts.push([lat, lon]);
        }
        return pts;
    }

    const wpSA = intermediatePoints(startCoords, [aLat, aLon]);
    const wpAB = intermediatePoints([aLat, aLon], [bLat, bLon]);
    const wpBS = intermediatePoints([bLat, bLon], startCoords);

    // Build full waypoint list
    const waypoints = [
        startCoords,
        ...wpSA, [aLat, aLon],
        ...wpAB, [bLat, bLon],
        ...wpBS, startCoords
    ];

    const routeData = await fetchRouteGeometry(waypoints);
    if (!routeData) return null;

    const distKm = Math.round(routeData.distance / 1000);
    const durH = Math.round(routeData.duration / 3600 * 10) / 10;

    const waypointNames = ["Start"];
    wpSA.forEach((_, i) => waypointNames.push(`Via ${i + 1}`));
    waypointNames.push(`Punt A (${cityA})`);
    wpAB.forEach((_, i) => waypointNames.push(`Via ${i + 1}`));
    waypointNames.push(`Punt B (${cityB})`);
    wpBS.forEach((_, i) => waypointNames.push(`Via ${i + 1}`));
    waypointNames.push("Start");

    return {
        name: `Toer via ${cityA} en ${cityB} (${distKm} km)`,
        icon: "\uD83D\uDD36",
        km: distKm,
        duration: `~${durH} uur`,
        durationHours: durationHours,
        difficulty: durationHours <= 2 ? "easy" : durationHours <= 3 ? "medium" : "advanced",
        difficultyLabel: durationHours <= 2 ? "Beginner" : durationHours <= 3 ? "Gemiddeld" : "Gevorderd",
        tags: [],
        country: selectedCountry,
        waypoints: waypointNames,
        coords: waypoints,
        highlights: [`Via ${cityA}`, `Via ${cityB}`, "Driehoeksroute", "Binnenwegen"],
        description: `Driehoekstoer via ${cityA} en ${cityB}. Totaal ${distKm} km over binnenwegen. Drie duidelijk verschillende richtingen voor maximale variatie. Geschatte rijtijd: ~${durH} uur.`,
        _generatedGeometry: routeData.geometry,
        _isGenerated: true
    };
}

// ============================================================
//  STATE
// ============================================================
let selectedCountry = "nl";
let userCoords = null;
let filterDur = "all";
let filterType = "all";
let selectedRouteIdx = null;
let currentRouteGeometry = null;
let addedStops = {};    // routeIdx -> [{lat, lon, name, insertIdx}]
let activePOIType = null;
let generatedRoutes = [];
let generatedByDur = {};  // { "2": [route,...], "3": [...], ... } cache per duration

// ============================================================
//  MAP SETUP
// ============================================================
const map = L.map("map", { scrollWheelZoom: false }).setView([51.5, 5.5], 7);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: '\u00a9 <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    maxZoom: 18
}).addTo(map);

let mapRouteLayer = L.layerGroup().addTo(map);
let poiLayer = L.layerGroup().addTo(map);
let attractionLayer = L.layerGroup().addTo(map);

function showMapLoading(text) {
    const el = document.getElementById("mapLoading");
    document.getElementById("mapLoadingText").textContent = text || "Route laden...";
    el.classList.add("visible");
}

function hideMapLoading() {
    document.getElementById("mapLoading").classList.remove("visible");
}

// ============================================================
//  SHOW ROUTE ON MAP (async — fetches real road geometry)
// ============================================================
async function showRouteOnMap(idx) {
    mapRouteLayer.clearLayers();
    poiLayer.clearLayers();
    attractionLayer.clearLayers();
    activePOIType = null;
    document.querySelectorAll(".poi-btn").forEach(b => b.classList.remove("active"));

    const route = getAllRoutes()[idx];
    const color = diffColors[route.difficulty] || "#e94560";

    showMapLoading("Route laden via wegen...");

    let geometry;
    if (route._generatedGeometry) {
        geometry = route._generatedGeometry;
    } else {
        // Build waypoints including any added stops
        const waypoints = buildWaypointsWithStops(idx);
        const routeData = await fetchRouteGeometry(waypoints);
        if (routeData) {
            geometry = routeData.geometry;
        } else {
            // Fallback to straight lines
            geometry = route.coords;
        }
    }

    currentRouteGeometry = geometry;

    // Draw polyline
    L.polyline(geometry, { color: color, weight: 4, opacity: 0.85 }).addTo(mapRouteLayer);

    // Draw waypoint markers
    const waypoints = buildWaypointsWithStops(idx);
    const wpNames = buildWaypointNamesWithStops(idx);

    waypoints.forEach((c, i) => {
        const isStart = (i === 0 || i === waypoints.length - 1);
        const isStop = i > 0 && i < wpNames.length && wpNames[i] && wpNames[i]._isStop;
        const markerColor = isStop ? "#4285f4" : color;

        const marker = L.circleMarker(c, {
            radius: isStart ? 8 : (isStop ? 7 : 5),
            fillColor: markerColor,
            color: "#fff",
            weight: isStart ? 2.5 : 1.5,
            fillOpacity: isStart ? 1 : 0.85
        }).addTo(mapRouteLayer);

        const name = typeof wpNames[i] === 'object' ? wpNames[i].name : (wpNames[i] || route.waypoints[0]);
        marker.bindPopup(`<strong>${name}</strong><br><em>${route.name}</em>`);
        if (i === 0) marker.openPopup();
    });

    map.fitBounds(geometry, { padding: [40, 40] });
    document.getElementById("mapEmpty").classList.add("hidden");
    hideMapLoading();

    // Show POI bar
    document.getElementById("poiBar").classList.add("visible");

    // Load attractions in background
    loadAttractions(geometry);
}

async function loadAttractions(geometry) {
    try {
        const attractions = await searchAttractionsAlongRoute(geometry);
        attractionLayer.clearLayers();
        attractions.forEach(a => {
            const marker = L.marker([a.lat, a.lon], {
                icon: L.divIcon({
                    className: 'poi-div-icon',
                    html: `<span class="attraction-emoji">${a.emoji}</span>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                }),
                zIndexOffset: -100
            }).addTo(attractionLayer);

            let popup = `<strong>${a.emoji} ${a.name}</strong>`;
            if (a.description) popup += `<br><em>${a.description}</em>`;
            marker.bindPopup(popup);
        });
    } catch (e) {
        console.warn("Attractions laden mislukt:", e);
    }
}

function clearMap() {
    mapRouteLayer.clearLayers();
    poiLayer.clearLayers();
    attractionLayer.clearLayers();
    currentRouteGeometry = null;
    activePOIType = null;
    document.getElementById("poiBar").classList.remove("visible");
    document.getElementById("poiClear").style.display = "none";
    document.querySelectorAll(".poi-btn").forEach(b => b.classList.remove("active"));
    document.getElementById("mapEmpty").classList.remove("hidden");
    if (userCoords) {
        map.setView(userCoords, 8);
    } else {
        map.setView([51.5, 5.5], 7);
    }
}

// ============================================================
//  WAYPOINT MANAGEMENT (added stops)
// ============================================================
function buildWaypointsWithStops(idx) {
    const route = getAllRoutes()[idx];
    const coords = [...route.coords];
    const stops = addedStops[idx] || [];
    // Insert stops in reverse order of insertIdx to preserve indices
    const sorted = [...stops].sort((a, b) => b.insertIdx - a.insertIdx);
    sorted.forEach(s => {
        coords.splice(s.insertIdx, 0, [s.lat, s.lon]);
    });
    return coords;
}

function buildWaypointNamesWithStops(idx) {
    const route = getAllRoutes()[idx];
    const names = route.waypoints.map(n => n);
    const stops = addedStops[idx] || [];
    const sorted = [...stops].sort((a, b) => b.insertIdx - a.insertIdx);
    sorted.forEach(s => {
        names.splice(s.insertIdx, 0, { name: s.name, _isStop: true });
    });
    return names;
}

function addStopToRoute(lat, lon, name) {
    if (selectedRouteIdx === null) return;
    const route = getAllRoutes()[selectedRouteIdx];
    const coords = route.coords;

    // Find best segment to insert
    let bestIdx = 1, bestDist = Infinity;
    for (let i = 0; i < coords.length - 1; i++) {
        const d = pointToSegmentDist([lat, lon], coords[i], coords[i + 1]);
        if (d < bestDist) { bestDist = d; bestIdx = i + 1; }
    }

    if (!addedStops[selectedRouteIdx]) addedStops[selectedRouteIdx] = [];
    addedStops[selectedRouteIdx].push({ lat, lon, name, insertIdx: bestIdx });

    // Re-render: clear geometry cache for this route, then re-show
    const cacheKey = buildWaypointsWithStops(selectedRouteIdx).map(c => `${c[0].toFixed(4)},${c[1].toFixed(4)}`).join('|');
    routeGeomCache.delete(cacheKey);

    showRouteOnMap(selectedRouteIdx);
    renderRoutes();
}

function removeStopFromRoute(stopIdx) {
    if (selectedRouteIdx === null) return;
    const stops = addedStops[selectedRouteIdx];
    if (!stops) return;
    stops.splice(stopIdx, 1);
    showRouteOnMap(selectedRouteIdx);
    renderRoutes();
}

// ============================================================
//  POI BAR HANDLERS
// ============================================================
document.querySelectorAll(".poi-btn").forEach(btn => {
    btn.addEventListener("click", async () => {
        const type = btn.dataset.poi;
        if (!currentRouteGeometry || !type) return;

        // Toggle off
        if (btn.classList.contains("active")) {
            btn.classList.remove("active");
            poiLayer.clearLayers();
            document.getElementById("poiClear").style.display = "none";
            activePOIType = null;
            return;
        }

        // Deactivate others
        document.querySelectorAll(".poi-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        btn.classList.add("loading");
        activePOIType = type;

        try {
            const pois = await searchPOIsAlongRoute(currentRouteGeometry, type);
            poiLayer.clearLayers();

            const emoji = poiTypes[type].emoji;
            pois.forEach(poi => {
                const marker = L.marker([poi.lat, poi.lon], {
                    icon: L.divIcon({
                        className: 'poi-div-icon',
                        html: `<span class="poi-emoji">${emoji}</span>`,
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(poiLayer);

                let popup = `<strong>${poi.name}</strong>`;
                if (poi.brand) popup += `<br>${poi.brand}`;
                if (poi.address) popup += `<br>${poi.address}${poi.city ? ', ' + poi.city : ''}`;
                if (poi.cuisine) popup += `<br>Keuken: ${poi.cuisine}`;
                if (poi.opening_hours) popup += `<br><em>${poi.opening_hours}</em>`;
                if (poi.phone) popup += `<br>Tel: ${poi.phone}`;

                const safeName = poi.name.replace(/'/g, "\\'").replace(/"/g, "&quot;");
                popup += `<br><button class="poi-add-btn" onclick="addStopToRoute(${poi.lat},${poi.lon},'${safeName}')">+ Toevoegen als tussenstop</button>`;

                marker.bindPopup(popup);
            });

            // Show count
            const existingCount = btn.querySelector(".poi-count");
            if (existingCount) existingCount.remove();
            const badge = document.createElement("span");
            badge.className = "poi-count";
            badge.textContent = pois.length;
            btn.appendChild(badge);

            document.getElementById("poiClear").style.display = pois.length > 0 ? "inline-block" : "none";
        } catch (e) {
            console.error("POI zoeken mislukt:", e);
        }

        btn.classList.remove("loading");
    });
});

document.getElementById("poiClear").addEventListener("click", () => {
    poiLayer.clearLayers();
    document.querySelectorAll(".poi-btn").forEach(b => {
        b.classList.remove("active");
        const badge = b.querySelector(".poi-count");
        if (badge) badge.remove();
    });
    document.getElementById("poiClear").style.display = "none";
    activePOIType = null;
});

// ============================================================
//  GOOGLE MAPS & GPX
// ============================================================
function getGoogleMapsUrl(route, idx) {
    const wp = buildWaypointsWithStops(idx !== undefined ? idx : 0);
    const names = buildWaypointNamesWithStops(idx !== undefined ? idx : 0);
    const allNames = names.map(n => typeof n === 'object' ? n.name : n);
    return "https://www.google.com/maps/dir/" + allNames.map(w => encodeURIComponent(w)).join("/");
}

function generateGPX(route, idx) {
    const time = new Date().toISOString();
    const coords = buildWaypointsWithStops(idx);
    const names = buildWaypointNamesWithStops(idx).map(n => typeof n === 'object' ? n.name : n);

    let gpx = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="Motorroutes NL-BE-DE"\n     xmlns="http://www.topografix.com/GPX/1/1">\n  <metadata><name>${route.name}</name><time>${time}</time></metadata>\n  <rte><name>${route.name}</name>\n`;
    coords.forEach((c, i) => {
        gpx += `    <rtept lat="${c[0]}" lon="${c[1]}"><name>${names[i] || "WP"+(i+1)}</name></rtept>\n`;
    });
    gpx += `  </rte>\n  <trk><name>${route.name}</name><trkseg>\n`;
    const geom = currentRouteGeometry || coords;
    geom.forEach(c => {
        gpx += `      <trkpt lat="${c[0]}" lon="${c[1]}"></trkpt>\n`;
    });
    gpx += `    </trkseg></trk>\n</gpx>`;
    return gpx;
}

function downloadGPX(idx) {
    const route = getAllRoutes()[idx];
    const blob = new Blob([generateGPX(route, idx)], { type: "application/gpx+xml" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = route.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "") + ".gpx";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// ============================================================
//  HELPERS
// ============================================================
function getAllRoutes() {
    return [...routes, ...generatedRoutes];
}

function setStatus(text) {
    const el = document.getElementById("welcomeStatus");
    if (el) el.textContent = text;
}

// ============================================================
//  FILTER LOGIC
// ============================================================
function routeMatchesFilters(route) {
    if (filterDur !== "all") {
        const d = parseInt(filterDur);
        if (d === 5) { if (route.durationHours < 5) return false; }
        else { if (route.durationHours !== d) return false; }
    }
    if (filterType !== "all") {
        if (filterType !== route.difficulty && !route.tags.includes(filterType)) return false;
    }
    return true;
}

function getFilteredRoutes() {
    const all = getAllRoutes();
    let filtered = all.map((r, i) => ({ route: r, idx: i })).filter(o => {
        // When a postcode is entered, only show generated routes
        if (userCoords && !o.route._isGenerated) return false;
        return routeMatchesFilters(o.route);
    });
    return filtered;
}

// ============================================================
//  RENDER ROUTES
// ============================================================
const container = document.getElementById("routes");

function renderRoutes() {
    container.innerHTML = "";
    const prevSelected = selectedRouteIdx;
    selectedRouteIdx = null;
    clearMap();

    const filtered = getFilteredRoutes();
    document.getElementById("routeCount").textContent = `(${filtered.length})`;

    filtered.forEach(({ route, idx, dist }) => {
        const card = document.createElement("div");
        card.className = `route-card glow-${route.difficulty}`;
        card.dataset.idx = idx;

        const names = buildWaypointNamesWithStops(idx);
        let wpHtml = "";
        names.forEach((n, i) => {
            if (i > 0) wpHtml += '<span class="arrow">\u203A</span>';
            if (typeof n === 'object' && n._isStop) {
                wpHtml += `<span class="stop-added" title="Klik om te verwijderen" data-stop-idx="${addedStops[idx] ? addedStops[idx].findIndex(s => s.name === n.name) : -1}">${n.name} \u2715</span>`;
            } else {
                wpHtml += `<span class="wp">${typeof n === 'object' ? n.name : n}</span>`;
            }
        });

        const flag = countryFlags[route.country] || "";
        const distTag = (dist !== undefined) ? `<span class="meta-tag">\u{1F4CD} ${Math.round(dist)} km</span>` : "";
        const mapsUrl = getGoogleMapsUrl(route, idx);
        const stopsCount = (addedStops[idx] || []).length;
        const stopsTag = stopsCount > 0 ? `<span class="meta-tag">\u{1F6D1} ${stopsCount} stop${stopsCount > 1 ? 's' : ''}</span>` : "";

        const accentClass = route._isGenerated ? 'accent-generated' : `accent-${route.difficulty}`;
        const diffClass = route._isGenerated ? 'generated' : route.difficulty;

        card.innerHTML = `
            <div class="route-accent ${accentClass}"></div>
            <div class="route-header">
                <h2><span class="route-icon">${route.icon}</span> ${route.name}</h2>
            </div>
            <div class="route-meta">
                <span class="meta-tag">${flag}</span>
                <span class="meta-tag">${route.km} km</span>
                <span class="meta-tag">${route.duration}</span>
                <span class="meta-tag">${route.waypoints[0]}</span>
                ${distTag}
                ${stopsTag}
            </div>
            <div class="route-waypoints">${wpHtml}</div>
            <div class="route-body"><p>${route.description}</p></div>
            <div class="route-highlights">
                ${route.highlights.map(h => `<span class="highlight-tag">${h}</span>`).join("")}
            </div>
            <div class="route-footer">
                <span class="difficulty ${diffClass}">${route.difficultyLabel}</span>
                <span class="route-type">${route.waypoints[0]} \u2192 ${route.waypoints[route.waypoints.length-1]}</span>
            </div>
            <div class="route-actions">
                <a href="${mapsUrl}" target="_blank" rel="noopener" class="action-btn nav-btn" onclick="event.stopPropagation()">
                    \u{1F4CD} Navigeer
                </a>
                <button class="action-btn gpx-btn" onclick="event.stopPropagation();downloadGPX(${idx})">
                    \u{1F4E5} Download GPX
                </button>
            </div>
        `;

        // Stop removal click handlers
        card.querySelectorAll(".stop-added").forEach(tag => {
            tag.addEventListener("click", (e) => {
                e.stopPropagation();
                const si = parseInt(tag.dataset.stopIdx);
                if (si >= 0) removeStopFromRoute(si);
            });
        });

        card.addEventListener("click", () => {
            const wasSelected = card.classList.contains("selected");
            document.querySelectorAll(".route-card.selected").forEach(c => c.classList.remove("selected"));

            if (wasSelected) {
                selectedRouteIdx = null;
                clearMap();
            } else {
                card.classList.add("selected");
                selectedRouteIdx = idx;
                showRouteOnMap(idx);
                card.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
        });

        container.appendChild(card);

        // Re-select previously selected
        if (prevSelected === idx) {
            card.classList.add("selected");
            selectedRouteIdx = idx;
            showRouteOnMap(idx);
        }
    });
}

// ============================================================
//  GENERATE 3 ROUTES FOR A GIVEN DURATION (with caching)
// ============================================================
const routeAngles = [
    Math.PI * 0.25,  // NE
    Math.PI * 1.0,   // S
    Math.PI * 1.6    // WNW
];
const backupAngles = [Math.PI * 0.6, Math.PI * 1.4, Math.PI * 1.9, 0, Math.PI * 0.8];

async function generateRoutesForDuration(durHours, showStatus) {
    const key = String(durHours);
    if (generatedByDur[key] && generatedByDur[key].length >= 3) return generatedByDur[key];

    generatedByDur[key] = [];

    // Pick random but spread-out directions for the 3 route types
    const baseAngle = Math.random() * 2 * Math.PI;
    const loopAngle = baseAngle;
    const destDirection = baseAngle + Math.PI * 0.7;      // ~126° offset
    const triangleRotation = baseAngle + Math.PI * 1.4;   // ~252° offset

    // Route 1: Local loop (existing algorithm)
    if (showStatus) showMapLoading(`Route 1 van 3 genereren — lokale lus (${durHours} uur)...`);
    try {
        const route = await generateLoopRoute(userCoords, durHours, loopAngle);
        if (route) generatedByDur[key].push(route);
    } catch (e) {
        console.warn("Loop route failed:", e);
    }

    // Route 2: Destination route (to a city and back via different road)
    if (showStatus) showMapLoading(`Route 2 van 3 genereren — bestemmingsrit (${durHours} uur)...`);
    try {
        const route = await generateDestinationRoute(userCoords, durHours, destDirection);
        if (route) generatedByDur[key].push(route);
    } catch (e) {
        console.warn("Destination route failed:", e);
    }

    // Route 3: Triangle route (3-point tour)
    if (showStatus) showMapLoading(`Route 3 van 3 genereren — driehoekstoer (${durHours} uur)...`);
    try {
        const route = await generateTriangleRoute(userCoords, durHours, triangleRotation);
        if (route) generatedByDur[key].push(route);
    } catch (e) {
        console.warn("Triangle route failed:", e);
    }

    // Fill up to 3 with backup loop routes if any failed
    let ai = 0;
    while (generatedByDur[key].length < 3 && ai < backupAngles.length) {
        if (showStatus) showMapLoading(`Reserveroute genereren...`);
        try {
            const route = await generateLoopRoute(userCoords, durHours, backupAngles[ai]);
            if (route) generatedByDur[key].push(route);
        } catch (e) { /* skip */ }
        ai++;
    }

    if (showStatus) hideMapLoading();
    return generatedByDur[key];
}

// ============================================================
//  FILTER BUTTONS (main app) — generates routes on demand
// ============================================================
document.querySelectorAll(".filter-section .filter-btn").forEach(btn => {
    btn.addEventListener("click", async () => {
        const group = btn.dataset.group;
        document.querySelectorAll(`.filter-btn[data-group="${group}"]`).forEach(b => b.classList.remove("active"));
        btn.classList.add("active");

        if (group === "dur") {
            filterDur = btn.dataset.val;
            // If postcode mode: generate routes for this duration if not cached
            if (userCoords) {
                const durHours = filterDur === "all" ? null : parseInt(filterDur);
                if (durHours && !generatedByDur[String(durHours)]) {
                    await generateRoutesForDuration(durHours, true);
                }
                // Rebuild generatedRoutes from all cached durations
                rebuildGeneratedRoutes();
            }
        }
        if (group === "type") filterType = btn.dataset.val;
        renderRoutes();
        updateBadge();
    });
});

function rebuildGeneratedRoutes() {
    generatedRoutes = [];
    for (const dur of Object.keys(generatedByDur)) {
        generatedRoutes.push(...generatedByDur[dur]);
    }
}

function updateBadge() {
    const badge = document.getElementById("heroBadge");
    if (userCoords) {
        const visible = getFilteredRoutes().length;
        badge.textContent = `${visible} route${visible !== 1 ? 's' : ''} vanaf jouw postcode`;
    } else {
        badge.textContent = `${routes.length} routes \u2022 3 landen \u2022 alle niveaus`;
    }
}

// ============================================================
//  WELCOME SCREEN
// ============================================================
document.querySelectorAll(".country-btn").forEach(btn => {
    btn.addEventListener("click", () => {
        document.querySelectorAll(".country-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        selectedCountry = btn.dataset.country;
    });
});

document.querySelectorAll("#welcomeDuration .dur-btn").forEach(btn => {
    btn.addEventListener("click", () => {
        document.querySelectorAll("#welcomeDuration .dur-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
    });
});

async function enterApp(dur) {
    filterDur = dur;
    document.querySelectorAll('[data-group="dur"]').forEach(b => {
        b.classList.toggle("active", b.dataset.val === String(dur));
    });

    const pc = document.getElementById("postcodeInput").value.trim();
    if (pc) {
        setStatus("Postcode opzoeken...");
        userCoords = await geocodePostcode(pc, selectedCountry);
        if (!userCoords) {
            setStatus("Postcode niet gevonden. Controleer je invoer.");
            return;
        }
        setStatus("Locatie gevonden!");

        // Generate routes for the selected duration
        const durHours = (dur === "all") ? 3 : parseInt(dur);
        await generateRoutesForDuration(durHours, false);
        rebuildGeneratedRoutes();
    }

    const welcome = document.getElementById("welcome");
    welcome.classList.add("hide");
    setTimeout(() => {
        welcome.style.display = "none";
        map.invalidateSize();
    }, 600);

    setStatus("");
    renderRoutes();
    updateBadge();

    // Auto-select first generated route
    if (userCoords && generatedRoutes.length > 0) {
        setTimeout(() => {
            const card = document.querySelector(`[data-idx="${routes.length}"]`);
            if (card) card.click();
        }, 300);
    }
}

document.getElementById("welcomeGo").addEventListener("click", () => {
    const durBtn = document.querySelector("#welcomeDuration .dur-btn.active");
    enterApp(durBtn.dataset.dur);
});

document.getElementById("welcomeSkip").addEventListener("click", () => enterApp("all"));

// Enter key on postcode input
document.getElementById("postcodeInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") document.getElementById("welcomeGo").click();
});

// Initial render (behind welcome screen)
renderRoutes();
updateBadge();
</script>

</body>
</html>
